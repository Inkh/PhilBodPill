# Vulnerability Report based on OWASP assessment list

## SQL Injection

SQL Injections happen when malicious code intent on manipulating your database is passed in via client side. 

SQL Injections could allow the perpetrator to view data on our customers or manipulate existing Product database.

An example of code vulnerable to such attacks are as follows:

```
string strQry = "SELECT * FROM Users WHERE UserName='" + txtUser.Text + "' AND Password='" + txtPassword.Text + "'";
```

Instead, use prepared statements like so:

```
var sql = @"Update [User] SET FirstName = @FirstName WHERE Id = @Id";
   context.Database.ExecuteSqlCommand(
      sql,
      new SqlParameter("@FirstName", firstname),
      new SqlParameter("@Id", id));
```

Using parameters can help with sanitizing input and ensuring that correct data is being passed in. Our site is secure against SQL injection due to the fact that we use Entity Framework to execute all our queries as parameters.

## Encryption

It is never recommended to write your own encryption, especially for sensitive data such as user password.

Do not do this:
```
string newPass = rvm.Password + "H5N30n[";
```

Or any other way that hashes passwords in a static form. Hashing is great because even if users have identical passwords, the hashes will still look different.

Since we're using .NET Core, the strongest encryption algorithm is 

 `Microsoft.AspNetCore.Cryptography.KeyDerivation.Pbkdf2`

An example would be:

```
byte[] pass = new byte[DATA_SIZE];
byte[] result;
SHA512 shaM = new SHA512Managed();
result = shaM.ComputeHash(pass);
```

## Application Secrets

It is never recommended to store sensitive data such as connection strings and API keys anywhere visible from the client side.

Instead, it's always preferred to use secrets to hide away that data from users.

Do not do this:
```
services.AddDbContext<UserDbContext>(options =>
            options.UseSqlServer({YOUR_KEY})
                );
```

Instead, store your keys in userSecrets and pull your data from there like so:

```
services.AddDbContext<UserDbContext>(options =>
            options.UseSqlServer(Configuration["ConnectionStrings:IdentityProductionConnection"])
                );
```

## Insecure Direct Object References
When you have a resource (object) which can be accessed by a reference (in the sample below this is the id) then you need to ensure that the user is intended to be there

Do not do this:

```
public ActionResult Edit(int id)
       {
           var user = _context.Users.FirstOrDefault(e => e.Id == id);
           return View("Details", new UserViewModel(user);
       }
```

Instead, do this:

```
public ActionResult Edit(int id)
       {
           var user = _context.Users.FirstOrDefault(e => e.Id == id);
           // Establish user has right to edit the details
           if (user.Id != _userIdentity.GetUserId())
           {
               HandleErrorInfo error = new HandleErrorInfo(new Exception("INFO: You do not have permission to edit these details"));
               return View("Error", error);
           }
           return View("Edit", new UserViewModel(user);
       }
```

This is done to prevent users from accessing routes or pages that they do not have the rights to. For example, only an admin should be able to perform CRUD operations on Products existing on the database. Another example would be a user going into another user's page and editing their details.
